# -*- coding: utf-8 -*-
"""[Clustering] Submission Akhir BMLP_Muhammad Aziz Habiburrahim

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7mIf5sySn1cCVmPeX4SYKyb6ExlvhGW

# **1. Perkenalan Dataset**

Tahap pertama, Anda harus mencari dan menggunakan dataset **tanpa label** dengan ketentuan sebagai berikut:

1. **Sumber Dataset**:  
   Dataset dapat diperoleh dari berbagai sumber, seperti public repositories (*Kaggle*, *UCI ML Repository*, *Open Data*) atau data primer yang Anda kumpulkan sendiri.
   
2. **Ketentuan Dataset**:
   - **Tanpa label**: Dataset tidak boleh memiliki label atau kelas.
   - **Jumlah Baris**: Minimal 1000 baris untuk memastikan dataset cukup besar untuk analisis yang bermakna.
   - **Tipe Data**: Harus mengandung data **kategorikal** dan **numerikal**.
     - *Kategorikal*: Misalnya jenis kelamin, kategori produk.
     - *Numerikal*: Misalnya usia, pendapatan, harga.

3. **Pembatasan**:  
   Dataset yang sudah digunakan dalam latihan clustering (seperti customer segmentation) tidak boleh digunakan.

# **2. Import Library**

Pada tahap ini, Anda perlu mengimpor beberapa pustaka (library) Python yang dibutuhkan untuk analisis data dan pembangunan model machine learning.
"""

# import library
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler,LabelEncoder, MinMaxScaler, OneHotEncoder
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.feature_selection import SelectKBest, f_classif, RFE
from sklearn.ensemble import RandomForestClassifier
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.compose import ColumnTransformer, make_column_selector
from sklearn.pipeline import Pipeline
from scipy import stats
from google.colab import drive
drive.mount('/content/drive')

"""# **3. Memuat Dataset**

Pada tahap ini, Anda perlu memuat dataset ke dalam notebook. Jika dataset dalam format CSV, Anda bisa menggunakan pustaka pandas untuk membacanya. Pastikan untuk mengecek beberapa baris awal dataset untuk memahami strukturnya dan memastikan data telah dimuat dengan benar.

Jika dataset berada di Google Drive, pastikan Anda menghubungkan Google Drive ke Colab terlebih dahulu. Setelah dataset berhasil dimuat, langkah berikutnya adalah memeriksa kesesuaian data dan siap untuk dianalisis lebih lanjut.
"""

# memuat dataset
df = pd.read_csv('/content/drive/My Drive/Course/Datasets/Dataset_clustering.csv')
df.head()

"""# **4. Exploratory Data Analysis (EDA)**

Pada tahap ini, Anda akan melakukan **Exploratory Data Analysis (EDA)** untuk memahami karakteristik dataset. EDA bertujuan untuk:

1. **Memahami Struktur Data**
   - Tinjau jumlah baris dan kolom dalam dataset.  
   - Tinjau jenis data di setiap kolom (numerikal atau kategorikal).

2. **Menangani Data yang Hilang**  
   - Identifikasi dan analisis data yang hilang (*missing values*). Tentukan langkah-langkah yang diperlukan untuk menangani data yang hilang, seperti pengisian atau penghapusan data tersebut.

3. **Analisis Distribusi dan Korelasi**  
   - Analisis distribusi variabel numerik dengan statistik deskriptif dan visualisasi seperti histogram atau boxplot.  
   - Periksa hubungan antara variabel menggunakan matriks korelasi atau scatter plot.

4. **Visualisasi Data**  
   - Buat visualisasi dasar seperti grafik distribusi dan diagram batang untuk variabel kategorikal.  
   - Gunakan heatmap atau pairplot untuk menganalisis korelasi antar variabel.

Tujuan dari EDA adalah untuk memperoleh wawasan awal yang mendalam mengenai data dan menentukan langkah selanjutnya dalam analisis atau pemodelan.
"""

# memahami struktur data
df.info()
print("Jumlah Baris:", df.shape[0])

# menangani data yang hilang
df.isnull().sum()

# analisis distribusi dan korelasi
df.describe(include=np.number)

# analisis distribusi dan korelasi
df.describe(exclude=np.number)

# visualisasi data
df.hist(figsize=(10, 8))
plt.show()

"""# **5. Data Preprocessing**

Pada tahap ini, data preprocessing adalah langkah penting untuk memastikan kualitas data sebelum digunakan dalam model machine learning. Data mentah sering kali mengandung nilai kosong, duplikasi, atau rentang nilai yang tidak konsisten, yang dapat memengaruhi kinerja model. Oleh karena itu, proses ini bertujuan untuk membersihkan dan mempersiapkan data agar analisis berjalan optimal.

Berikut adalah tahapan-tahapan yang bisa dilakukan, tetapi **tidak terbatas** pada:
1. Menghapus atau Menangani Data Kosong (Missing Values)
2. Menghapus Data Duplikat
3. Normalisasi atau Standarisasi Fitur
4. Deteksi dan Penanganan Outlier
5. Encoding Data Kategorikal
6. Binning (Pengelompokan Data)

Cukup sesuaikan dengan karakteristik data yang kamu gunakan yah.
"""

# menghapus atau menangani data kosong (missing values)
df.dropna(inplace=True)

# menghapus data duplikat
df.drop_duplicates()

# normalisasi atau standarisasi fitur
df_sample = df.sample(2000)
df_sample = df_sample.drop(['soil_type', 'crop_type', 'fertilizer_name'], axis=1)
df_sample.isnull().sum()
df_sample.info()

# normalisasi atau standarisasi fitur
encoder = ColumnTransformer([
    ('categorical', OneHotEncoder(), make_column_selector(dtype_exclude=np.number))
], remainder='passthrough')

preprocessor = Pipeline([
    ('encoder', encoder),
    ('Scaler', StandardScaler())
])
df_preprocessed = preprocessor.fit_transform(df_sample)

# deteksi dan penanganan outlier
z_scores_temparature = np.abs(stats.zscore(df['temparature']))
threshold = 3
outlier_mask_temparature = z_scores_temparature > threshold
outliers_temparature = df[outlier_mask_temparature]
print("Outlier berdasarkan Z-Score:\n", outliers_temparature)

z_scores_humidity = np.abs(stats.zscore(df['humidity']))
threshold = 3
outlier_mask_humidity = z_scores_humidity > threshold
outliers_humidity = df[outlier_mask_humidity]
print("Outlier berdasarkan Z-Score:\n", outliers_humidity)

z_scores_moisture = np.abs(stats.zscore(df['moisture']))
threshold = 3
outlier_mask_moisture = z_scores_moisture > threshold
outliers_moisture = df[outlier_mask_moisture]
print("Outlier berdasarkan Z-Score:\n", outliers_moisture)

z_scores_nitrogen = np.abs(stats.zscore(df['nitrogen']))
threshold = 3
outlier_mask_nitrogen = z_scores_nitrogen > threshold
outliers_nitrogen = df[outlier_mask_nitrogen]
print("Outlier berdasarkan Z-Score:\n", outliers_nitrogen)

z_scores_potassium = np.abs(stats.zscore(df['potassium']))
threshold = 3
outlier_mask_potassium = z_scores_potassium > threshold
outliers_potassium = df[outlier_mask_potassium]
print("Outlier berdasarkan Z-Score:\n", outliers_potassium)

z_scores_phosphorous = np.abs(stats.zscore(df['phosphorous']))
threshold = 3
outlier_mask_phosphorous = z_scores_phosphorous > threshold
outliers_phosphorous = df[outlier_mask_phosphorous]
print("Outlier berdasarkan Z-Score:\n", outliers_phosphorous)

# encoding data kategorikal
le = LabelEncoder()
df['soil_type_encoded'] = le.fit_transform(df['soil_type'])
df['crop_type_encoded'] = le.fit_transform(df['crop_type'])
df['fertilizer_name_encoded'] = le.fit_transform(df['fertilizer_name'])
df.head(100)

# binning (pengelompokan data)
df_grouped_soil_type = df.groupby('soil_type')['soil_type_encoded'].mean().reset_index()
print(df_grouped_soil_type)

df_grouped_crop_type = df.groupby('crop_type')['crop_type_encoded'].mean().reset_index()
print(df_grouped_crop_type)

df_grouped_fertilizer_name = df.groupby('fertilizer_name')['fertilizer_name_encoded'].mean().reset_index()
print(df_grouped_fertilizer_name)

"""# **6. Pembangunan Model Clustering**

## **a. Pembangunan Model Clustering**

Pada tahap ini, Anda membangun model clustering dengan memilih algoritma yang sesuai untuk mengelompokkan data berdasarkan kesamaan. Berikut adalah **rekomendasi** tahapannya.
1. Pilih algoritma clustering yang sesuai.
2. Latih model dengan data menggunakan algoritma tersebut.
"""

# pembagunan model clustering
range_n_clusters = range(2, 21)
silhouette_scores = []

for n_clusters in range_n_clusters:
  kmeans = KMeans(n_clusters=n_clusters, random_state=42)
  cluster_labels = kmeans.fit_predict(df_preprocessed)
  silhouette_avg = silhouette_score(df_preprocessed, cluster_labels)
  silhouette_scores.append(silhouette_avg)
  print(f"For n_clusters = {n_clusters}, the average silhouette_score is : {silhouette_avg}")

plt.plot(range_n_clusters, silhouette_scores, marker='o')
plt.xlabel('Number of Clusters (n_clusters)')
plt.ylabel('Silhouette Score')
plt.title('Silhouette Score VS Number of Clusters')
plt.show()

"""## **b. Evaluasi Model Clustering**

Untuk menentukan jumlah cluster yang optimal dalam model clustering, Anda dapat menggunakan metode Elbow atau Silhouette Score.

Metode ini membantu kita menemukan jumlah cluster yang memberikan pemisahan terbaik antar kelompok data, sehingga model yang dibangun dapat lebih efektif. Berikut adalah **rekomendasi** tahapannya.
1. Gunakan Silhouette Score dan Elbow Method untuk menentukan jumlah cluster optimal.
2. Hitung Silhouette Score sebagai ukuran kualitas cluster.
"""

# evaluasi model clustering
kmeans = KMeans(n_clusters=3, random_state=42)
cluster_labels = kmeans.fit_predict(df_preprocessed)
silhouette_avg = silhouette_score(df_preprocessed, cluster_labels)
print(f"The average silhouette_score is : {silhouette_avg}")

"""## **c. Feature Selection (Opsional)**

Silakan lakukan feature selection jika Anda membutuhkan optimasi model clustering. Jika Anda menerapkan proses ini, silakan lakukan pemodelan dan evaluasi kembali menggunakan kolom-kolom hasil feature selection. Terakhir, bandingkan hasil performa model sebelum dan sesudah menerapkan feature selection.
"""

# inisialisasi PCA dengan jumlah komponen yang diinginkan
pca = PCA(n_components=6)

# fit dan transform data yang telah dipreprocess
pca_result = pca.fit_transform(df_preprocessed)

# visualisasi explained variance ratio
explained_variance_ratio = pca.explained_variance_ratio_
cumulative_variance_ratio = np.cumsum(explained_variance_ratio)

plt.figure(figsize=(10, 6))
plt.plot(range(1, len(explained_variance_ratio) + 1), explained_variance_ratio, marker='o', linestyle='--')
plt.plot(range(1, len(cumulative_variance_ratio) + 1), cumulative_variance_ratio, marker='o')

plt.xlabel('Number of Components')
plt.ylabel('Variance Explained')
plt.title('Explained Variance Ratio')
plt.legend(['Individual Explained Variance', 'Cumulative Explained Variance'])
plt.grid(True)
plt.show()

# rata rata silhouette score
kmeans = KMeans(n_clusters=3, random_state=42)
cluster_labels = kmeans.fit_predict(pca_result)
silhouette_avg = silhouette_score(pca_result, cluster_labels)
print(f"The average silhouette_score is : {silhouette_avg}")

"""## **d. Visualisasi Hasil Clustering**

Setelah model clustering dilatih dan jumlah cluster optimal ditentukan, langkah selanjutnya adalah menampilkan hasil clustering melalui visualisasi.

Berikut adalah **rekomendasi** tahapannya.
1. Tampilkan hasil clustering dalam bentuk visualisasi, seperti grafik scatter plot atau 2D PCA projection.
"""

# visualisasi hasil clustering
# inisialisasi t-SNE
tsne = TSNE(n_components=2, random_state=42)

# fit dan transform data hasil PCA
tsne_result = tsne.fit_transform(pca_result)

# buat scatter plot
plt.figure(figsize=(10, 8))
sns.scatterplot(x=tsne_result[:, 0], y=tsne_result[:, 1], hue=cluster_labels, palette="viridis")
plt.title("t-SNE Visualization of Clusters")
plt.xlabel("t-SNE Component 1")
plt.ylabel("t-SNE Component 2")
plt.show()

# label cluster
df_sample['clusters'] = cluster_labels
df_sample.info()

# identifikasi kolom numerik dan kategorikal
numerical_cols = df_sample.select_dtypes(include=['number']).columns.tolist()

# include 'soil_type' and 'crop_type' in df_sample if they are in the original df
categorical_cols = []
for col in ['soil_type', 'crop_type', 'fertilizer_name']:
    if col in df.columns:
        df_sample[col] = df.loc[df_sample.index, col]
        categorical_cols.append(col)

# jumlah total plot (jumlah numerik + jumlah kategorikal)
total_plots = len(numerical_cols) + len(categorical_cols)

# buat figure dengan subplots
fig, axes = plt.subplots(nrows=1, ncols=total_plots, figsize=(5 * total_plots, 6))

# plot boxplot untuk fitur numerik
for i, col in enumerate(numerical_cols):
    sns.boxplot(x='clusters', y=col, data=df_sample, ax=axes[i])
    axes[i].set_title(f'Boxplot of {col} by Cluster')
    axes[i].set_xlabel('Cluster')
    axes[i].set_ylabel(col)

# plot stacked bar chart untuk fitur kategorikal
for j, col in enumerate(categorical_cols, start=len(numerical_cols)):
    cluster_counts = df_sample.groupby(['clusters', col]).size().unstack(fill_value=0)
    cluster_counts.plot(kind='bar', stacked=True, ax=axes[j])
    axes[j].set_title(f'Distribution of {col} across Clusters')
    axes[j].set_xlabel('Cluster')
    axes[j].set_ylabel('Count')
    axes[j].legend(title=col)

# buat dictionary untuk menyimpan hasil analisis
cluster_summary = {}

# loop melalui setiap cluster, using 'clusters' column from df_sample
for cluster in df_sample['clusters'].unique():
    cluster_data = df_sample[df_sample['clusters'] == cluster]
    summary = {}

    # analisis untuk data numerik
    for col in numerical_cols:
        summary[col] = {
            'mean': cluster_data[col].mean(),
            'min': cluster_data[col].min(),
            'max': cluster_data[col].max()
        }

    # analisis untuk data kategorikal
    for col in categorical_cols:
        summary[col] = {'mode': cluster_data[col].mode()[0] if not cluster_data[col].mode().empty else None}

    cluster_summary[cluster] = summary

# konversi hasil ke DataFrame untuk tampilan lebih rapi
summary_df = pd.DataFrame.from_dict({(i,j): cluster_summary[i][j]
                                     for i in cluster_summary.keys()
                                     for j in cluster_summary[i].keys()},
                                    orient='index')


# atur layout agar tidak tumpang tindih
plt.tight_layout()
plt.show()
print(summary_df)

"""## **e. Analisis dan Interpretasi Hasil Cluster**
Berikut adalah analisis karakteristik statistik untuk setiap cluster yang dihasilkan dari temparature, humidity, moisture, nitrogen, potassium, phosphorous, soil_type, crop_type dan fertilizer_name.

## **Cluster 0:**
- **Rata-rata temperature (°C):** 30.49 (Min: 20.28, Max: 40).
- **Rata-rata humidity (%):** 58.71 (Min: 41.97, Max: 80).
- **Rata-rata moisture (%):** 42.67 (Min: 20, Max: 70).
- **Rata-rata nitrogen (N):** 37.87 (Min: 23, Max: 46).
- **Rata-rata potassium (K):** 0.92 (Min: 0, Max: 4).
- **Rata-rata phosphorous (P):** 1.22 (Min: 0, Max: 18).
- **Modus soil_type:** Clayey.
- **Modus crop_type:** Maize.
- **Modus fertilizer_name:** 20-20.
- **Analisis:** Cluster ini menunjukkan kondisi tanah liat dengan kelembaban tanah sedang. Kandungan nitrogen cukup tinggi, sedangkan kalium dan fosfor sangat rendah. Kondisi ini cocok untuk tanaman jagung dengan pupuk NPK 20-20 yang seimbang.

## **Cluster 1:**
- **Rata-rata temperature (°C):** 27.03 (Min: 20, Max: 34.83).
- **Rata-rata humidity (%):** 53.81 (Min: 40.37, Max: 69.36).
- **Rata-rata moisture (%):** 41.12 (Min: 20, Max: 70).
- **Rata-rata nitrogen (N):** 13.32 (Min: 0, Max: 28).
- **Rata-rata potassium (K):** 4.80 (Min: 0, Max: 23).
- **Rata-rata phosphorous (P):** 20,57 (Min: 4, Max: 45).
- **Modus soil_type:** Sandy.
- **Modus crop_type:** Cotton.
- **Modus fertilizer_name:** 14-26-26.
- **Analisis:** Cluster ini memiliki tanah berpasir yang cenderung memiliki kandungan nitrogen lebih rendah dibandingkan Cluster 0. Kalium cukup tinggi, sedangkan fosfor juga cukup tinggi. Tanaman kapas cocok dengan kondisi ini, dengan pupuk 14-26-26 yang mengandung lebih banyak fosfor untuk mendukung pertumbuhan akar.

## **Cluster 2:**
- **Rata-rata temperature (°C):** 33.56 (Min: 24.98, Max: 40).
- **Rata-rata humidity (%):** 64.48 (Min: 48.95, Max: 79.57).
- **Rata-rata moisture (%):** 46.92 (Min: 20.00, Max: 70).
- **Rata-rata nitrogen (N):** 12.35 (Min: 0.00, Max: 28).
- **Rata-rata potassium (K):** 4.73 (Min:0.00, Max: 23).
- **Rata-rata phosphorous (P):** 26.49 (Min: 4.00, Max: 46).
- **Modus soil_type:** Red.
- **Modus crop_type:** Cotton.
- **Modus fertilizer_name:** 14-35-14.
- **Analisis:** Cluster ini memiliki suhu tertinggi dibandingkan yang lain, dengan kelembaban yang cukup tinggi. Tanah merah memiliki kadar fosfor lebih tinggi dibandingkan Cluster 1 dan lebih cocok untuk tanaman kapas. Pupuk 14-35-14 mendukung pertumbuhan tanaman dengan kandungan fosfor yang tinggi.

## **Kesimpulan dan Strategi Bisnis**

### **Kesimpulan:**
Berdasarkan analisis karakteristik setiap cluster, dapat disimpulkan bahwa: Cluster 0 lebih cocok untuk budidaya jagung di tanah liat dengan pupuk NPK seimbang (20-20). Cluster 1 dan Cluster 2 sama-sama cocok untuk kapas, tetapi tanahnya berbeda. Cluster 1 (Sandy soil) lebih rendah fosfornya dan menggunakan pupuk 10-26-26. Cluster 2 (Red soil) memiliki fosfor lebih tinggi dan menggunakan pupuk 14-35-14. Cluster dengan suhu tertinggi adalah Cluster 2, sedangkan yang paling dingin adalah Cluster 1. Kelembaban tanah cukup seragam di semua cluster, tetapi kandungan nitrogen lebih tinggi di Cluster 0.

Strategi Bisnis:

### **Strategi Bisnis:**
1. **Cluster 0**
   - Bisa dimanfaatkan untuk pertanian tanaman dengan kebutuhan unsur hara tinggi, seperti sayuran berdaun hijau atau tanaman dengan siklus pertumbuhan cepat.
2. **Cluster 1**
   - Lebih cocok untuk tanaman yang tidak memerlukan banyak nutrisi tambahan, seperti tanaman kering atau tanaman lokal yang bisa bertahan di kondisi tanah miskin hara.
3. **Cluster 2**
   - Cocok untuk tanaman yang membutuhkan kelembaban tinggi, seperti padi atau tanaman tropis lainnya.

# **7. Mengeksport Data**

Simpan hasilnya ke dalam file CSV.
"""

df_sample.to_csv("Dataset_inisiasi.csv", index=False)